from enum import Enum
from time import time

from sqlalchemy.exc import IntegrityError

from utils.log import logger

from . import (
    agreements,
    assessments,
    bms_products,
    cancellation_policies,
    connected_content_fields,
    forum_categories,
    languages,
    message_products,
    modules,
    questionnaires,
    referral_code_categories,
    resources,
    roles,
    specialties,
    specialty_keywords,
    tags,
    text_copies,
    us_states,
    user_flags,
    verticals,
)

log = logger(__name__)


class Fixture(Enum):
    """A category of data that can be exported and restored from the current environment.

    The value of a fixture designates the order in which it is exported and restored in
    cases where internal dependencies exist across fixtures.
    """

    AGREEMENTS = 1
    FORUM_CATEGORIES = 2
    REFERRAL_CODE_CATEGORIES = 3
    ROLES = 4
    VERTICALS = 5
    SPECIALTIES = 6
    SPECIALTY_KEYWORDS = 7
    TAGS = 8
    TEXT_COPIES = 9
    USER_FLAGS = 10
    US_STATES = 11
    LANGUAGES = 12
    CANCELLATION_POLICIES = 13
    MODULES_WITHOUT_ASSESSMENTS = 14
    ASSESSMENTS = 15
    MODULES = 16
    CONNECTED_CONTENT_FIELDS = 19
    RESOURCES = 20
    BMS_PRODUCTS = 23
    MESSAGE_PRODUCTS = 24
    QUESTIONNAIRES = 25


_FN = {
    Fixture.AGREEMENTS: (agreements.export, agreements.restore),
    Fixture.FORUM_CATEGORIES: (forum_categories.export, forum_categories.restore),
    Fixture.REFERRAL_CODE_CATEGORIES: (
        referral_code_categories.export,
        referral_code_categories.restore,
    ),
    Fixture.ROLES: (roles.export, roles.restore),
    Fixture.SPECIALTIES: (specialties.export, specialties.restore),
    Fixture.SPECIALTY_KEYWORDS: (specialty_keywords.export, specialty_keywords.restore),
    Fixture.TAGS: (tags.export, tags.restore),
    Fixture.TEXT_COPIES: (text_copies.export, text_copies.restore),
    Fixture.USER_FLAGS: (user_flags.export, user_flags.restore),
    Fixture.VERTICALS: (verticals.export, verticals.restore),
    Fixture.US_STATES: (None, us_states.restore),
    Fixture.LANGUAGES: (None, languages.restore),
    Fixture.CANCELLATION_POLICIES: (None, cancellation_policies.restore),
    Fixture.MODULES_WITHOUT_ASSESSMENTS: (None, modules.restore_without_assessments),
    Fixture.ASSESSMENTS: (assessments.export, assessments.restore),
    Fixture.MODULES: (modules.export, modules.restore),
    Fixture.CONNECTED_CONTENT_FIELDS: (
        connected_content_fields.export,
        connected_content_fields.restore,
    ),
    Fixture.RESOURCES: (resources.export, resources.restore),
    Fixture.BMS_PRODUCTS: (bms_products.export, bms_products.restore),
    Fixture.MESSAGE_PRODUCTS: (message_products.export, message_products.restore),
    Fixture.QUESTIONNAIRES: (questionnaires.export, questionnaires.restore),
}
assert all(f in _FN for f in Fixture)


def export() -> None:
    from pprint import pformat
    from sys import maxsize

    def fmt_entity_list(ee, indent):  # type: ignore[no-untyped-def] # Function is missing a type annotation
        return ",\n".join(f"{' ' * indent}{pformat(e, width=maxsize)}" for e in ee)

    def fmt(data):  # type: ignore[no-untyped-def] # Function is missing a type annotation

        # List[Any]
        if isinstance(data, list):
            return "[\n{}\n]".format(fmt_entity_list(data, 4))

        # Dict[List[Any]]
        if isinstance(data, dict) and all(isinstance(v, list) for v in data.values()):
            return "{{\n    {}\n}}".format(
                ",\n    ".join(
                    "'{}': [\n{}\n    ]".format(k, fmt_entity_list(v, 8))
                    for k, v in data.items()
                )
            )

        raise NotImplementedError(
            "Define a format that results in meaningful diffs, or use an above format."
        )

    def _export(f):  # type: ignore[no-untyped-def] # Function is missing a type annotation
        fn, _ = _FN[f]
        return fn.__module__, fn.__name__, f.name, fmt(fn())

    print("# See `dev export --help` for more information.")
    print("import datetime")
    print("from decimal import Decimal")
    print()
    print(
        "\n\n".join(
            "# Generated by {}.{}\n{} = {}".format(*_export(f))
            for f in sorted(Fixture, key=lambda e: e.value)
            if _FN[f][0]
        )
    )


_RESTORE_FROM = {
    Fixture.MODULES_WITHOUT_ASSESSMENTS: Fixture.MODULES,
    Fixture.US_STATES: None,
    Fixture.LANGUAGES: None,
    Fixture.CANCELLATION_POLICIES: None,
}


def _snapshot(f):  # type: ignore[no-untyped-def] # Function is missing a type annotation
    source = _RESTORE_FROM.get(f, f)
    if source:
        from . import snapshot

        return (getattr(snapshot, source.name),)
    return ()


def restore(fixtures, benchmark=True):  # type: ignore[no-untyped-def] # Function is missing a type annotation
    """restore populates the database with the snapshot data exported for the specified fixtures.

    Args:
        fixtures: The collection of fixtures to be restored.
        benchmark: Whether or not to log the time it takes to restore fixtures.
    """
    from storage.connection import db

    ff = sorted(fixtures, key=lambda e: e.value)
    log.info("Restoring fixtures.", fixtures=(*(e.name for e in ff),))
    all_start = time()
    for f in ff:
        try:
            with db.session.begin_nested():
                start = time()
                _, restore_f = _FN[f]
                args = _snapshot(f)
                restore_f(*args)
                end = time()
                if benchmark:
                    log.debug(
                        "Restored %s in %dms", f.name, int(round((end - start) * 1000))
                    )
        except IntegrityError as e:
            error_string = str(e).split("\n", maxsplit=1)[0]
            log.error("Got an error restoring fixture.", fixture=f, error=error_string)
    log.info("Done restoring fixtures.", seconds=time() - all_start)
